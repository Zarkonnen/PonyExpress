<!DOCTYPE html>
<html style="margin: 0; padding: 0;">
    <head>
        <title>Game</title>
        <script src="jquery-3.1.1.min.js"></script>
        <script src="howler.min.js"></script>
    </head>
    <body style="margin: 0; padding: 0; background: black;">
        <canvas width="800" height="600" allowfullscreen="true" id="gameCanvas" style="margin-left: 10px; margin-top: 10px;"></canvas>
        <script>

var interaction = {
    "text": "HYPERSPACE PONY EXPRESS: DON'T THINK ABOUT DEATH EDITION\n\nW Move Pony Up\nS Move Pony Down\nA Gold Phase\nD Sky Phase",
    "options": ["Start"]
};

const storyInterval = 10000;

var stories = [{
    "text": "HYPERSPACE PONY EXPRESS: DON'T THINK ABOUT DEATH EDITION\n\nW Move Pony Up\nS Move Pony Down\nA Gold Phase\nD Sky Phase",
    "options": ["Start"]
}];
var storyIndex = 0;
var storyTime = 0;

var streaks = [];
var blackStreak = null;

const WHITE = -1;
const YELLOW = 0;
const BLUE = 1;
const BLACK = 2;

function spawnStreak() {
    var color = Math.random() > 0.5 ? BLUE : YELLOW;
    var colors = [["rgba(249, 188, 16, 0.5", "#f9bc10", "white"], ["rgba(0, 172, 175, 0.5", "#00acaf", "white"]][color];
    streaks.push({
        startY: Math.random(),
        endY: Math.random(),
        h: 0.03 + Math.random() * 0.06,
        color: color,
        colors: colors,
        values: [],
        time: 0,
        age: 0,
        lifespan: 3000 + Math.random() * 20000
    });
}

function spawnBlackStreak() {
    var colors = ["rgba(0, 0, 0, 0.5", "white", "black"];
    blackStreak = {
        y: Math.random(),
        h: 0.03 + Math.random() * 0.06,
        color: BLACK,
        colors: colors,
        values: [],
        time: 0,
        age: 0,
        lifespan: 1000000
    };
    streaks.push(blackStreak);
}

spawnStreak();
spawnStreak();
spawnStreak();

var ponyTriangles = [];

ponyTriangles.push({
    angle: 0,
    minRadius: 0.04,
    maxRadius: 0.06,
    radiusFrequency: 0.007,
    radiusPhase: 918,
    angularSpeed: 0.01,
    minOpacity: 0.5,
    maxOpacity: 0.7,
    opacityFrequency: 0.03,
    opacityPhase: 666,
    points: [0, Math.PI * 2 / 3, Math.PI * 2 / 3 * 2]
});

ponyTriangles.push({
    angle: 78,
    minRadius: 0.03,
    maxRadius: 0.06,
    radiusFrequency: 0.0027,
    radiusPhase: 401,
    angularSpeed: -0.005,
    minOpacity: 0.5,
    maxOpacity: 0.7,
    opacityFrequency: 0.01,
    opacityPhase: 48,
    points: [0, Math.PI * 2 / 5, Math.PI * 2 / 5 * 2, Math.PI * 2 / 5 * 3, Math.PI * 2 / 5 * 4]
});

ponyTriangles.push({
    angle: 901,
    minRadius: 0.04,
    maxRadius: 0.05,
    radiusFrequency: 0.009,
    radiusPhase: 22,
    angularSpeed: 0.001,
    minOpacity: 0.2,
    maxOpacity: 0.4,
    opacityFrequency: 0.002,
    opacityPhase: 123,
    points: [0, Math.PI * 2 / 7, Math.PI * 2 / 7 * 2, Math.PI * 2 / 7 * 3, Math.PI * 2 / 7 * 4, Math.PI * 2 / 7 * 5, Math.PI * 2 / 7 * 6]
});

const numValues = 20;
const speed = 1.5;
const ponyX = 0.2;
var ponyY = 0.5;
var time = 0;
var ponyR = 255; var ponyG = 255; var ponyB = 255;
var ponyColor = WHITE;
var whiteoutAmount = 0;

function tick(ms) {
    const w = canvas.width;
    const h = canvas.height;
    c.resetTransform();

    if (whiteoutAmount >= 1) {
        c.fillStyle = "white";
        c.fillRect(0, 0, w, h);
        return;
    }

    if (storyIndex >= stories.length && !interaction) {
        whiteoutAmount += ms / 5000.0;
    }

    if (interaction) {
        ms = 0; 
        ponyR = 255;
        ponyG = 255;
        ponyB = 255;
        ponyColor = WHITE;
    } else {
        if (pressed("W")) {
            ponyY = Math.max(0.1, ponyY - ms * 0.001);
        }
        if (pressed("S")) {
            ponyY = Math.min(0.9, ponyY + ms * 0.001);
        }
        if (pressed("D")) {
            ponyR = 249;
            ponyG = 188;
            ponyB = 16;
            ponyColor = YELLOW;
        } else if (pressed("A")) {
            ponyR = 0;
            ponyG = 172;
            ponyB = 175;
            ponyColor = BLUE;
        } else {
            ponyR = 255;
            ponyG = 255;
            ponyB = 255;
            ponyColor = WHITE;
        }
    }
    
    time += ms;
    storyTime += ms;
    
    if (storyTime >= storyInterval && !blackStreak && storyIndex < stories.length) {
        spawnBlackStreak();
        storyTime -= storyInterval;
    }
    
    var fr = Math.floor(249 * (Math.sin(time * 0.001) * 0.5 + 0.25) / 2);
    var fg = Math.floor(188 * (Math.sin(time * 0.001) * 0.5 + 0.25) / 2 + 172 * (Math.cos(time * 0.002) * 0.5 + 0.25) / 2);
    var fb = Math.floor(16 * (Math.sin(time * 0.001) * 0.5 + 0.25) / 2 + 175 * (Math.cos(time * 0.002) * 0.5 + 0.25) / 2);
    
    c.fillStyle = "rgb(" + fr + ", " + fg + ", " + fb + ")";
    
    c.fillRect(0, 0, w, h);
    
    var ponyJitter = 0;
    
    for (s of streaks) {
        s.time += ms;
        s.age += ms;
        
        var sY = 0;
        
        if (s.color == BLACK) {
            if (s.y > ponyY + 0.02) {
                s.y -= ms * 0.0005;
            } else if (s.y < ponyY - 0.02) {
                s.y += ms * 0.0005;
            } else if (s.values.length >= numValues && !interaction) {
                interaction = stories[storyIndex++];
            }
            sY = s.y;
        } else {
            sY = s.startY + (s.endY - s.startY) * s.age / s.lifespan;
        }
        
        if (s.time > 1000 / numValues / speed) {
            s.time -= 1000 / numValues / speed;
            if (s.values.length > numValues + 1) {
                s.values.splice(0, 1);
            }
            s.values.push((Math.random() * 0.5 + 0.5) * s.h);
        }
        var streakHDiv = 1;
        if (s.age > s.lifespan - 1000) {
            streakHDiv += (1000 - s.lifespan + s.age) / 100;
        }
        
        var streakH = s.h / streakHDiv;
        
        if (s.values.length >= numValues && Math.abs(ponyY - sY) < streakH + 0.1) {
            if (ponyColor != s.color) {
                ponyJitter++;
            }
        }
        
        for (color of s.colors) {
            c.fillStyle = color;
            c.beginPath();
            var streakX = w * ((numValues + 2.0) / numValues - s.time / 1000.0 * speed);
            c.moveTo(streakX, h * sY);
            for (var i = s.values.length - 1; i >= 0; i--) {
                streakX -= w * 1.0 / numValues;
                c.lineTo(streakX, h * (sY + s.values[i] / streakHDiv));
            }
            streakX -= w * 1.0 / numValues;
            c.lineTo(streakX, h * sY);
            for (var i = 0; i < s.values.length; i++) {
                streakX += w * 1.0 / numValues;
                c.lineTo(streakX, h * (sY - s.values[i] / streakHDiv));
            }
            c.closePath();
            c.fill();
            streakHDiv++;
        }
    }
    
    if (interaction) {
        ponyJitter = 0;
    }
    
    streaks = streaks.filter(function(s) {
        return s.age < s.lifespan;
    });
    
    var expectedNumberOfStreaks = Math.floor(3 + time / 10000);
    if ((whiteoutAmount > 0 || (streaks.length < expectedNumberOfStreaks) && Math.random() < 0.001 * ms)) {
        spawnStreak();
    }
    
    for (t of ponyTriangles) {
        t.angle += t.angularSpeed * ms;
        var tOpacity = t.minOpacity + (t.maxOpacity - t.minOpacity) * (Math.sin(time * t.opacityFrequency + t.opacityPhase) + 0.5);
        var tRadius = t.minRadius + (t.maxRadius - t.minRadius) * (Math.sin(time * t.radiusFrequency + t.radiusPhase) + 0.5);
        c.fillStyle = "rgba(" + ponyR + ", " + ponyG + ", " + ponyB + ", " + tOpacity + ")";
        c.beginPath();
        var started = false;
        for (p of t.points) {
            var pAngle = t.angle + p;
            var pX = ponyX * w + Math.cos(pAngle) * tRadius * w + (Math.random() - 0.5) * ponyJitter * w * 0.03;
            var pY = ponyY * h + Math.sin(pAngle) * tRadius * w + (Math.random() - 0.5) * ponyJitter * w * 0.03;
            if (started) {
                c.lineTo(pX, pY);
            } else {
                c.moveTo(pX, pY);
                started = true;
            }
        }
        c.closePath();
        c.fill();
        for (p of t.points) {
            var pAngle = t.angle + p;
            var pX = ponyX * w + Math.cos(pAngle) * tRadius * w;
            var pY = ponyY * h + Math.sin(pAngle) * tRadius * w;
            img("eye", pX, pY, w / tRadius * 0.001 / 256);
        }
    }
    
    if (interaction) {
        c.fillStyle = "rgba(0, 0, 0, 0.7)";
        c.fillRect(0, 0, w, h);
        c.fillStyle = "white";
        c.font = "4vmin sans-serif";
        var li = 0;
        for (l of interaction.text.split("\n")) {
            c.fillText(l, w * 0.1, w * 0.1 + li++ * 0.03 * w);
        }
        li++;
        
        c.fillStyle = "#f9bc10";
        var oi = 0;
        for (l of interaction.options) {
            var hotkey = ["1", "2", "3", "4"][oi];
            if (pressed(hotkey)) {
                keyCodes[hotkey] = false;
                keys[hotkey] = false;
                interaction = interaction.next;
                streaks = streaks.filter(function(s) {
                    return s != blackStreak;
                });
                blackStreak = null;
                return;
            }
            c.fillText("[" + hotkey + "] " + l, w * 0.1, w * 0.1 + li++ * 0.03 * w);
        }
    }
    
    if (whiteoutAmount > 0) {
        c.fillStyle = "rgba(255, 255, 255, " + whiteoutAmount + ")";
        c.fillRect(0, 0, w, h);
    }
}


function hwl(name, volume) {
    return new Howl({src: ["sounds/" + name + ".ogg", "sounds/" + name + ".mp3", "sounds/" + name + ".wav"], volume: volume || 1});
}

var images = {};

function img(img, x, y, scale) {
    if (img == null) { return; }
    if (!images[img]) {
        images[img] = new Image();
        images[img].src = "graphics/" + img + ".png";
    }
    c.drawImage(images[img], x - images[img].width * scale / 2, y - images[img].height * scale / 2, images[img].width * scale, images[img].height * scale);
}

var canvas = document.getElementById("gameCanvas");
var c = canvas.getContext("2d");
var keys = {};
var keyCodes = {};
var click = null;
var mouseDown = false;
var cursor = {x: 300, y: 300};

// Listen for key presses.
function canvasKeyDown(e) {
    keyCodes[e.which] = true;
    keys[String.fromCharCode(e.which)] = true;
}


function canvasKeyUp(e) {
    keyCodes[e.which] = false;
    keys[String.fromCharCode(e.which)] = false;
}

function pressed(key) {
    return !!keys[key] || !!keyCodes[key];
}

$('body').keyup(canvasKeyUp).keydown(canvasKeyDown);

// Listen for mouse stuff.
function canvasClick(e) {
    click = { "x": e.offsetX, "y": e.offsetY };
}

function canvasMouseDown(e) {
    mouseDown = true;
}

function canvasMouseUp(e) {
    mouseDown = false;
}

function canvasMove(e) {
    cursor = { "x": e.offsetX, "y": e.offsetY };
}

$('#gameCanvas').click(canvasClick).mousemove(canvasMove).mousedown(canvasMouseDown).mouseup(canvasMouseUp);

// Set up game loop.
var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
var lastUpdate = new Date().getTime();

function nextFrame() {
    var currentTime = new Date().getTime();
    tick(currentTime - lastUpdate);
    click = null;
    lastUpdate = currentTime;
    requestAnimationFrame(nextFrame);
}

// Once everything is set up, start game loop.
requestAnimationFrame(nextFrame);

jQuery(window).resize(function() {
    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 20;
});
jQuery(window).ready(function() {
    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 20;
});
 
/*canvas.addEventListener("click", function() {
    if (canvas.webkitRequestFullScreen) {
        canvas.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);
    } else if (canvas.mozRequestFullScreen) {
        canvas.mozRequestFullScreen();
    } else if (canvas.requestFullScreen) {
        canvas.requestFullScreen();
    }
});*/
        </script>
    </body>
</html>
